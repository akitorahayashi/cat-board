# 猫画像表示アプリにおける SwiftData 最適化戦略

このドキュメントでは、猫画像表示アプリに SwiftData を導入する目的と、アプリのパフォーマンスおよびメモリ効率を高めるための戦略をまとめます。

## 🌟 導入目的

| 目的            | 説明                               |
| ------------- | -------------------------------- |
| ✅ 画像URLの永続化   | アプリを再起動しても過去に取得した画像を保持           |
| ✅ APIリクエストの削減 | 既に取得済みの画像はローカルから再利用              |
| ✅ メモリ使用量の抑制   | 表示中の画像のみをメモリに保持                  |
| ✅ オフライン対応     | ローカルに保存された画像URLにより、ネット接続なしでも表示可能 |

## 🧱 実装構成

### 1. モデルの定義

`CatImageEntity` モデルを作成し、画像URLと保存日時を保持します。

```swift
@Model
class CatImageEntity {
    @Attribute(.unique) var url: String
    var createdAt: Date = Date()

    init(url: String) {
        self.url = url
    }
}
```

### 2. データ保存戦略

画像APIから取得した画像URLを SwiftData に保存し、次回以降の読み込みに利用します。

```swift
for model in newItems {
    if !modelContext.contains(where: { $0.url == model.imageURL }) {
        let entity = CatImageEntity(url: model.imageURL)
        modelContext.insert(entity)
    }
}
try? modelContext.save()
```

### 3. 起動時のローカルデータ読み込み

SwiftData から画像URLを読み込み、ViewModel に反映します。

```swift
@Query(sort: \.createdAt, order: .reverse) var storedImages: [CatImageEntity]

func loadCachedImages() {
    self.catImages = storedImages.map { CatImageModel(imageURL: $0.url, isLoading: false) }
}
```

### 4. フェッチ制御

保存済み画像の件数に応じて API フェッチを抑制します。

```swift
if storedImages.count < threshold {
    await fetchAdditionalImages()
}
```

### 5. データのスライドウィンドウ管理

保存件数が上限を超えた場合は、古い画像から削除します。

```swift
if storedImages.count > 300 {
    let excess = storedImages.dropFirst(300)
    excess.forEach(modelContext.delete)
    try? modelContext.save()
}
```

## 🚀 初回インストール後の起動フロー

初回起動においては、キャッシュされたローカルデータを優先的に表示することで表示の高速化を図りつつ、最新の画像を得るために追加のAPIフェッチを行う設計が求められます。これはUXとデータ鮮度のトレードオフを最小限に抑えるためのバランス施策です。

### 📌 最新性と再表示不要性のトレードオフについて

キャッシュを優先すると表示速度やデータ節約において大きなメリットがありますが、最新の画像を即座に取得するには向きません。そのため、以下のような折衷案が実践的です。また、このアプリは基本的に "ブラウジング用途" として設計されており、ユーザーは一度見た画像を再び見たいとはあまり考えていません。したがって、"一度表示した画像を除外する" 戦略と組み合わせることで、より効率的な体験を提供できます。

* 起動時に SwiftData を即座に反映しつつ、バックグラウンドで 1 回だけ API を呼び出して最新画像を取得し、先頭に追加
* 一定期間（例: 24時間）を過ぎたら強制的にリフレッシュを行う
* API からの取得結果とキャッシュをマージし、重複を排除して表示

1. アプリ起動時、SwiftUI の `onAppear` などで `ViewModel.onAppear()` を呼び出す。
2. `ViewModel` が SwiftData（`@Query`）を通じて `CatImageEntity` を読み込み、`catImages` に変換して画面に表示。
3. ローカルに保存された画像が少ない場合（例: 50件未満など）、API を使って画像を追加取得。
4. APIから取得した新しい画像の URL を SwiftData に保存。
5. 保存件数が上限（例: 300件）を超えていた場合、古いエントリから削除。
6. 表示は `LazyVStack` などでスクロール可能にし、ユーザーがスムーズに画像を閲覧できるようにする。

なお、API から 1 回で取得できる画像 URL は 10 件固定であるため、たとえば 50 件以上の画像が必要な場合には、最大 5 回のリクエストが必要になります。この仕様を考慮し、リクエスト回数を最小限に抑える設計（ローカル保存の優先利用）が重要です。

この一連の処理により、アプリの初回起動から即座に画像が表示され、以後も必要に応じてデータを増やしつつ、メモリ・ストレージ管理も自動的に行われます。

加えて、「一度表示した画像は再表示しない」という方針を取る場合は、SwiftData に表示済みフラグや閲覧履歴を記録し、それらを除外したリストを画面に反映する設計が有効です。これによりユーザー体験と効率性をさらに高めることができます。

## 🔁 SwiftData を使った循環型画像供給モデル

以下は、猫画像表示アプリが「一度見た画像は再表示しない」前提で、ユーザー体験とメモリ効率の両立を目指す設計戦略です。表示中・未表示の画像のみを効率的に管理するため、SwiftData を利用した循環型の画像供給モデルを構築します。

### 1. 画像URLの永続保存

**目的**：APIから取得した画像をローカルDBに保存して再利用可能にする。

**ワークフロー**：

1. APIから画像URL一覧を取得。
2. SwiftData内に、未登録のURLのみ `CatImageEntity` として保存。
3. 表示用の `catImages` 配列に反映。

---

### 2. 起動時のローカル画像読み込み

**目的**：アプリ起動時に即座に画像を表示できるようにする。

**ワークフロー**：

1. `@Query` で `CatImageEntity` 一覧を取得。
2. モデルを `CatImageModel` に変換し `catImages` にセット。
3. 表示処理に渡す。

---

### 3. 表示済みを除外した最新画像の取得

**目的**：一度表示された画像を除外しつつ、ユーザーがまだ見ていない画像のみを効率的に取得・表示する。

**ワークフロー**：

1. APIを最大5回まで呼び出し（1回10件）画像URLを取得。
2. 取得結果から、SwiftData内にすでに存在する or `isViewed == true` の画像を除外。
3. 未閲覧の画像のみを `CatImageEntity` に保存し、`catImages` に反映。
4. SwiftUI上では新規画像のみが上に追加される形で表示される。

---

### 5. 表示済み画像の管理（再表示防止）

**目的**：一度表示された画像を再び表示しないようにする。

**ワークフロー**：

1. 表示対象の画像に `isViewed = true` などのフラグを設定。
2. SwiftData 保存時にこの情報を更新。
3. 次回起動時、`isViewed == false` の画像のみを表示。

---

### 6. 一定枚数以下になったら一括取得（再補充）

**目的**：画像が足りなくなる前に次のデータ群を用意して、途切れないUXを維持する。

**ワークフロー**：

1. 未表示画像の残りが閾値（例: 20枚）を下回ったら、
2. APIを複数回連続で呼び出して未閲覧のURLを取得、保存。
3. 画面にはすぐ表示せず、次の画面表示のためにキューに蓄積。

---

## 📷 画像プリフェッチ戦略と表示制御モデル

プリフェッチおよびURL・画像のロード数に関する制御は、アプリの性能とユーザー体験のバランスに直結します。そのため以下のように **ロード単位と制御方法の基準を明確に定義**することが重要です。

### 📦 ロード単位と閾値の考え方

#### ✅ URL取得の最適化方針

* APIは1回で10件の画像URLを返す仕様のため、**10件単位で複数回取得**する。
* 未表示URL数が一定枚数（例：200件）を超えたら、フェッチを停止。
* フェッチ対象は `isViewed == false` のものに限定。

#### ✅ 画像ロードの最適化方針

* 実際の画像データの読み込みは、**スクロールに合わせて1枚ずつ進める**。
* ただし、プリフェッチバッファの上限（例：30枚）を超えないように制御。
* メモリ使用やスクロール遅延を監視しながら、**シミュレータ・実機検証でチューニング**。

### 🔬 チューニングと判断基準

* URLは**通信量ベース**で、画像は**メモリ負荷とUXベース**で調整。
* 実際の使用中に Instruents や SwiftUI プロファイラで観測し、調整を行う。
* デフォルトの上限値は決めつつも、**実機や状況に応じた動的変更の仕組み**も検討対象。

画像URLと同様に、画像本体のロードも局所化（集中管理）することで効率化を図ります。ただし、ロード対象の画像数が固定されていると、端末スペックに対して過剰または不足となる可能性があり、UXに影響を与えるリスクがあります。特に、**オーバースペックな枚数をプリフェッチしてしまうと、低スペック端末では描画遅延やメモリ不足が発生する可能性があります。**

この課題に対応するためには、以下のような工夫が有効です：

### ⚙️ プリフェッチ対象の枚数を制御する方法

* **端末スペック依存のプリフェッチ枚数設定**：

  * 使用可能なRAM容量やCPUコア数に応じて、プリフェッチ枚数を動的に制限
  * 例：iPadやMシリーズMacなら50枚、iPhone SEなど低スペック機なら10〜20枚

* **画面サイズによるプリフェッチウィンドウの調整**：

  * スクロール領域＋α枚数を「1画面分 + 1.5画面分」などとして設計

* **パフォーマンス測定によるフィードバックループ**：

  * 初回起動後にスクロールパフォーマンスを計測し、一定以下ならプリフェッチ枚数を減らすような適応ロジックを検討

このように、画像ロードも局所化しつつ、**端末環境に応じて柔軟にコントロールできる仕組み**を併用することで、最大限の体験と安定性を両立することが可能です。

画像の実ロードが開始される前に、スクロールで表示されそうな範囲の画像を事前に取得（プリフェッチ）することで、ユーザーにとって滑らかで待ちのない体験を提供します。以下にこのアプリに適したプリフェッチ戦略をまとめます。

### 🔎 目的

* スクロール時に画像の読み込み遅延を感じさせない
* ネットワーク帯域やメモリを浪費せずに先読みする

### 📐 プリフェッチ戦略とタイミング

#### 1. 可視範囲+α を対象とした先読み

* SwiftUI の `onAppear` などを使い、**画面に表示される直前の画像URL** を検知
* その時点で Kingfisher などで `ImagePrefetcher` を使って画像を事前ダウンロード

#### 2. 一括キュー方式で分散的にプリフェッチ

* 表示対象（例：10件ごと）をグループ化してプリフェッチ対象にする
* あまり先の画像まではプリフェッチしない（例：現在+30件程度）

#### 3. バックグラウンドでの優先度調整

* 通信やスクロールに影響が出ないよう、低優先度での非同期プリフェッチ

### 🧠 実装のポイント（ViewModelの役割）

このプリフェッチ戦略の中核として、ViewModel に「次に表示する画像のリスト（プリフェッチエリア）」を保持する責任を持たせます。

#### 🧩 表示制御ワークフロー：

1. APIまたはSwiftDataから未閲覧画像URLを大量に取得。
2. ViewModelの `prefetchImages` リストに格納し、非同期に読み込み開始。
3. 実際に画面に表示されるタイミングで、その画像を `catImages` に移動（＝表示エリアへ投入）。
4. 移動後は `prefetchImages` から削除。
5. `prefetchImages` が閾値を下回ったら、再度SwiftDataまたはAPIから追加供給を行う。

このように、「供給（prefetch）→移動（表示）→消費（削除）」の流れを ViewModel 側で明確に分離管理することで、無駄のない効率的な画像表示が可能になります。

* Kingfisher なら `ImagePrefetcher` を使って `URL` 配列を一括先読みできる
* 表示済みになった画像は `KingfisherManager.shared.cache.removeImage(forKey:)` 等で適宜削除可
* SwiftData側では `isViewed == false` の画像に対してのみプリフェッチを行う

---

## ✅ まとめ

SwiftData を活用することで、猫画像表示アプリは以下の最適化が実現できます：

* メモリ使用量の抑制
* キャッシュによる表示速度向上
* API負荷の軽減
* オフライン対応によるUX向上

この戦略により、アプリのスケーラビリティとユーザー体験の両立が可能となります。
